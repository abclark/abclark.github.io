<!doctype html>
<html>
  <head>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_SVG">
    </script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>constrained birkhoff</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">  
      <section>
        <h1>Birkhoff-von Neumann decomposition with constraints</h1>

        <p><em>View the <a href="https://github.com/abclark/generalized_birkhoff_von_neumann">source of this content</a>.</em></p>

        <p>Decomposes a matrix into a weighted sum of basis matrices with binary entries satisfying user-imposed constraints. When the starting matrix is doubly stochastic and the basis matrices are required to be permutation matrices, this is the classical Birkhoff von-Neumann decomposition.
Here we implement the algorithm identified in <a href="http://faculty.chicagobooth.edu/eric.budish/research/Budish-Che-Kojima-Milgrom-2013-AER.pdf">Budish, Che, Kojima, and Milgrom 2013</a>. 
The constraints must form what they call a bihierarchy.</p>

        <h2>Installation</h2>
        
        <pre><code>pip install generalized_birkhoff_von_neumann</code></pre>
        
        <h2>Basic usage</h2>
        
        <pre><code>import numpy as np
from generalized_birkhoff_von_neumann import generalized_birkhoff_von_neumann_decomposition

# Create a matrix whose entries are between 0 and 1, and a constraint structure. 
#
#For example
#
# X = np.array([[.5, .2,.3], [.5,.5, 0], [.8, 0, .2], [.2, .3, .5]])
# 
# constraint_structure = {frozenset({(0, 0), (0, 1), (0,2)}): (1,3)}
#
# The first, and only, entry of this constraint structure requires that the 
# (0, 0), (0, 1), (0,2) entries of each basis matrix sum to 1, 2, or 3.

generalized_birkhoff_von_neumann_decomposition(X, constraint_structure)
</code></pre>
        
        <h2>Mathematical background</h2>
       
        <p>See <a href="http://faculty.chicagobooth.edu/eric.budish/research/Budish-Che-Kojima-Milgrom-2013-AER.pdf">Budish, Che, Kojima, and Milgrom 2013</a>.</p>

<h2>API</h2>
        
 <pre><code>>>> import numpy as np
>>> from generalized_birkhoff_von_neumann import generalized_birkhoff_von_neumann_decomposition
>>> X = np.array([[.5, .2,.3], [.5,.5, 0], [.8, 0, .2], [.2, .3, .5]])
>>> constraint_structure = {frozenset({(0, 0), (0, 1), (0,2)}): (1,1), frozenset({(1, 0), (1, 1), (1,2)}):(1,1), frozenset({(2, 0), (2, 1), (2,2)}):(1,1), frozenset({(3, 0), (3, 1), (3,2)}):(1,1), frozenset({(0, 0), (1, 0), (2,0), (3,0)}):(1,2), frozenset({(0, 1), (1, 1), (2,1), (3,1)}):(1,1), frozenset({(0, 2), (1, 2), (2,2), (3,2)}):(1,1), frozenset({(0, 0), (1, 0)}):(1,1)}
>>> generalized_birkhoff_von_neumann_decomposition(X,constraint_structure)
[[0.14285714285714288, 
0.3571428571428571, 
0.29999999999999999, 
0.057142857142857141, 
0.14285714285714282], 
[array([[ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.]]), 
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.]]), 
array([[ 0.,  0.,  1.],
       [ 1.,  0.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  1.,  0.]]), 
array([[ 0.,  1.,  0.],
       [ 1.,  0.,  0.],
       [ 0.,  0.,  1.],
       [ 1.,  0.,  0.]]), 
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.],
       [ 1.,  0.,  0.]])], 
1.0, 
array([[ 0.5,  0.2,  0.3],
       [ 0.5,  0.5,  0. ],
       [ 0.8,  0. ,  0.2],
       [ 0.2,  0.3,  0.5]])]
>>> </code></pre>

<h2>Application: probabalistic serial mechanism with constraints</h2>        
        
<p>There are \(n\) objects to be allocatd between \(m\) agents. Each agent has a ranking of the objects. Chances for winning a particular item are obtained by each agent simultaneously and at the same apeed 'eating' the probability mass of their top ranked item for which probability mass is still available. The outcome of this process is a list of probabilities for each agent. Together, these lists form an \(m \times n\) matrix \(X\) whose entry in its \(i\)'th row and \(j\)'th column is the probability that agent \(i\) wins object \(j\).</p>
        
<p>To implement these probabilities, one needs to find a distribution over allocations. This we represent as a weighted sum of permutation matrices of the same size as \(X\). This is the classical Birkhoff-von Neumann decomposition.</p>
  
<p>To impose additional constraints—e.g. each agent is allocated at least one item, no agent is allocated more than \(k\) items, etc—we can apply <code>generalized_birkhoff_von_neumann_decomposition</code>.</p>

<p>To run the probabalistic serial mechanism:</p> 
        
<h3>Installation</h3>
        
        <pre><code>pip install probabalistic_serial_mechanism</code></pre>
        
<h3>Basic usage</h3>
        
        <pre><code># Create a dictionary R with agent's as keys and rank order list as values.
#
#For example
#
# R = {0: [0,1,2], 1: [2,1,0]}

probabalistic_serial_mechanism(R)</code></pre>
        
        <h3>Mathematical background</h3>
       
        <p>See <a href="http://faculty.chicagobooth.edu/eric.budish/research/Budish-Che-Kojima-Milgrom-2013-AER.pdf">Budish, Che, Kojima, and Milgrom 2013</a>.</p>

<h3>API</h3>
        
 <pre><code>>>> from probabalistic_serial_mechanism import probabalistic_serial_mechanism
>>> R = {0: [0,1,2], 1: [2,1,0]}
>>> probabalistic_serial_mechanism(R)
{0: array([ 1. ,  0.5,  0. ]), 1: array([ 0. ,  0.5,  1. ])}
>>> </code></pre>

  
</section>
    <script src="javascripts/scale.fix.js"></script>
    </div>
  </body>
</html>
